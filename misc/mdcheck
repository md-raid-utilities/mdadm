#!/bin/bash

# Copyright (C) 2014-2017 Neil Brown <neilb@suse.de>
#
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    Author: Neil Brown
#    Email: <neilb@suse.com>

# This script should be run periodically to automatically
# perform a 'check' on any md arrays.
#
# It supports a 'time budget' such that any incomplete 'check'
# will be checkpointed when that time has expired.
# A subsequent invocation will allow the 'check' to continue.
#
# Options are:
#   --continue    Don't start new checks, only continue previously started ones.
#   --restart:    Enable restarting the array checks
#   --duration    This is passed to "date --date=$duration" to find out
#		  when to finish
#
# Arrays are identified by UUID and the 'sync_completed' value is stored
# in /var/lib/mdcheck/MD_UUID_$UUID. If this file exists on startup of
# the script, the check will continue where the previous check left off.
# After the check completes, /var/lib/mdcheck/Checked_$UUID will be created.
# Another full check will be started after this file is removed.
# Use "mdcheck --restart" to remove these markers and re-enable checking
# all arrays.

# get device name from sysfs
devname() {
    local dev
    [[ -f "$1/uevent" ]] && \
	    dev=$(. "$1/uevent" && echo -n "$DEVNAME")
    [[ "$dev" && -b "/dev/$dev" ]] || return 1
    echo -n "/dev/$dev"
}

args=$(getopt -o hcrd: -l help,continue,restart,duration: -n mdcheck -- "$@")
rv=$?
if [ $rv -ne 0 ]; then exit $rv; fi

eval set -- $args

cont=
restart=
endtime=
while [ " $1" != " --" ]
do
    case $1 in
	--help )
		echo >&2 'Usage: mdcheck [--restart|--continue] [--duration time-offset]'
		echo >&2 '  time-offset must be understood by "date --date"'
		exit 0
		;;
	--continue )
		cont=yes ;;
	--restart )
		restart=yes ;;
	--duration )
		shift; dur=$1
		endtime=$(date --date "$dur" "+%s")
		;;
    esac
    shift
done
shift

if [ "$cont" = yes ]; then
	if [ "$restart" = yes ]; then
		echo 'ERROR: --restart and --continue cannot be combined' >&2
		exit 1
	fi
elif [ "$restart" = yes ]; then
	echo 'Re-enabling array checks for all arrays' >&2
	rm -f /var/lib/mdcheck/Checked_*
	exit $?
fi

# We need a temp file occasionally...
tmp=/var/lib/mdcheck/.md-check-$$
cnt=0

cleanup() {
    # We've waited, and there are still checks running.
    # Time to stop them.
    for i in `eval echo {1..$cnt}`
    do
	eval fl=\$MD_${i}_fl
	eval sys=\$MD_${i}_sys
	eval dev=\$MD_${i}_dev

	if [ -z "$fl" ]; then continue; fi

	if [ "`cat $sys/md/sync_action`" != 'check' ]
	then
	    eval MD_${i}_fl=
	    rm -f $fl
	    continue;
	fi
	echo idle > $sys/md/sync_action
	cat $sys/md/sync_min > $fl
	logger -p daemon.info pause checking $dev at `cat $fl`
    done
    rm -f "$tmp"
}

trap 'exit 129' 2 3 15
trap 'cleanup' 0

# firstly, clean out really old state files
mkdir -p /var/lib/mdcheck
find /var/lib/mdcheck -name "MD_UUID*" -type f -mtime +180 -exec rm {} \;

# Now look at each md device.
for sync_act in /sys/block/*/md/sync_action
do
	[ -e "$sync_act" ] || continue
	if [ "`cat $sync_act`" != 'idle' ]
	then # This array is busy
		continue
	fi

	sys=${sync_act%/md/*}
	dev=$(devname "$sys") || continue
	mdadm --detail --export "$dev" | grep '^MD_UUID=' > $tmp || continue
	source $tmp
	[[ "$MD_UUID" ]] || continue

	fl="/var/lib/mdcheck/MD_UUID_$MD_UUID"
	checked="${fl/MD_UUID_/Checked_}"
	if [[ -f "$fl" ]]; then
		[[ ! -f "$checked" ]] || {
		    echo "WARNING: $checked exists, continuing anyway" >&2
		}
		start=`cat "$fl"`
	elif [[ ! -f "$checked" && -z "$cont" ]]; then
		start=0
	else # nothing to do
		continue
	fi

	: "$((cnt+=1))"
	eval MD_${cnt}_fl=\$fl
	eval MD_${cnt}_sys=\$sys
	eval MD_${cnt}_dev=\$dev
	echo $start > $fl
	echo $start > $sys/md/sync_min
	echo check > $sys/md/sync_action
	logger -p daemon.info mdcheck checking $dev from $start
done

if [ -z "$endtime" ]
then
	exit 0
fi

while [ `date +%s` -lt $endtime ]
do
	any=
	for i in `eval echo {1..$cnt}`
	do
		eval fl=\$MD_${i}_fl
		eval sys=\$MD_${i}_sys
		eval dev=\$MD_${i}_dev

		if [ -z "$fl" ]; then continue; fi

		if [ "`cat $sys/md/sync_action`" != 'check' ]
		then
			logger -p daemon.info mdcheck finished checking $dev
			eval MD_${i}_fl=
			rm -f "$fl"
			touch "${fl/MD_UUID_/Checked_}"
			continue;
		fi
		read a rest < $sys/md/sync_completed
		echo $a > $fl
		any=yes
	done
	# mdcheck_continue.timer is started by mdcheck_start.timer.
	# When the check action can be finished in mdcheck_start.service,
	# it doesn't need mdcheck_continue anymore.
	if [ -z "$any" ]; then
		systemctl stop mdcheck_continue.timer
		exit 0;
	fi
	sleep 220 &
	wait $!
done
